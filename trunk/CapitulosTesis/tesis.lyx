#LyX 1.6.4 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\use_default_options true
\language spanish
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Part
Introducción
\end_layout

\begin_layout Part
Dominio
\end_layout

\begin_layout Part
Trabajos Relacionados
\end_layout

\begin_layout Part
Identificación de atributos de calidad
\end_layout

\begin_layout Standard
En esta seccion se estudiará en profundidad el enfoque elegido para la técnica
 de identificacion de atributos de calidad en documentos de especificaciones
 de requirimientos.
 Esta técnica brindará una asistencia extra al analista, para identificar
 los atributos de calidad del sistema lo antes posible y evitar los problemas
 sucitados anteriormente.
\end_layout

\begin_layout Section
Desarrollo de la téncina de identificacion de atributos de calidad propuesta
\end_layout

\begin_layout Standard
Aca iria el grafico y explicariamos cada una de las etapas por arriba.
\end_layout

\begin_layout Section
Análisis de la Entrada
\end_layout

\begin_layout Standard
Este bloque de tareas tiene como finalidad llevar a cabo un análisis léxico
 y sintáctico de los textos definidos como entrada para la técnica.
 Esta entrada es la información generada como salida por la herramienta
 Aspect Extractor Tool [X].
 Se considera que la salida de dicha herramienta, luego del procesamiento
 con la técnica de “análisis semántico” [X], es la lista de casos de uso,
 los early aspects detectados y las relaciones entre ellos.
 Los casos de uso respetan el estándar establecido por Rational comentado
 en la sección XX.
 De igual forma, los early aspect respetarán el formato definido en el Aspect
 Extract Tool para la técnica de reconocimiento semántico.
 La técnica propuesta, a partir de esta información, crea las entidades
 Caso de Uso y Early Aspects con los cuál trabajará el algoritmo, basándose
 además en las relaciones entre estas entidades para agruparlos inicialmente
 en el Quality Attribute Theme.
 Un Quality Attribute Theme (QAT), básicamente está formado por un subconjunto
 de la especificación de casos de uso y un early aspect, que en forma conjunta
 hacen referencia a un atributo de calidad.
 En esta etapa del proceso, se completará la información de los casos de
 uso y early aspect, mientras se dejara pendiente instanciar la información
 del atributo de calidad.
 Esta información será justamente la que retorne el algoritmo.
\end_layout

\begin_layout Standard
Para este análisis en necesario realizar en primer lugar un pre procesamiento
 de los datos y luego un filtrado sobre los mismos.
 En estas actividades, se logrará determinar un subconjunto del conjunto
 de palabras que forman la especificación de los casos de uso y la definición
 del early aspect, las cuales serán relevantes para la identificación del
 atributo de calidad involucrado.
 
\end_layout

\begin_layout Subsection
Pre Procesamiento de los datos
\end_layout

\begin_layout Standard
El objetivo de esta tarea es procesar la entrada para dejar la información
 en un formato uniforme antes de que el algoritmo sea invocado.
 Este pre procesamiento es realizado a través de la separación de la información
 de las entidades de entrada en tokens.
 Sobre estos tokens se aplicará luego una secuencia de filtros para transformar
 las palabras de los casos de uso y early aspects a un formato esperado
 por el algoritmo.
 Se considera un token a una unidad básica de texto que puede ser enriquecida
 con diferentes atributos, como por ejemplo, peso, ocurrencias, etc.
 El resultado de este pre procesamiento es una lista de tokens para las
 palabras obtenidas de los casos de uso y otra lista de tokens para las
 palabras del early aspect.
 
\end_layout

\begin_layout Standard
Por ejemplo, considerando la siguiente fracción de un caso de uso:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nombre
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Registrar Usuario 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Descripción
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se registran los datos del usuario en el sistema
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Se genera la siguiente lista de tokens:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="11">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Registrar
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Usuario
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Se
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
registran
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
los
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
datos
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
del
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
usario
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
en
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
el
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sistema
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
section: desc
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Filtrado de los datos
\end_layout

\begin_layout Standard
Como se mencionó en la sección anterior, el filtrado de los datos es otra
 de las tareas que se realiza sobre la entrada.
 En este caso, se ejecutan una serie de filtros sobre los tokens de las
 listas de casos de uso y early aspects.
 Estos filtros, además, serán utilizados luego para el formateo de las palabras
 de la ontología.
 
\end_layout

\begin_layout Standard
Un filtro es una unidad de procesamiento que realiza una modificación (enriquece
, refina o transforma) sobre los datos de entrada y los copia a la salida
 para que otro filtro trabaje sobre los mismos datos.
 Mediante los filtros podemos realizar transformaciones independientes sobre
 el flujo de datos.
\end_layout

\begin_layout Standard
El patrón de arquitectura de tubos y filtros provee una estructura para
 procesar flujos de datos.
 Cada paso de procesamiento se encapsula en un filtro.
 Los datos se pasan usando los tubos entre filtros adyacentes.
 Recombinando los filtros se pueden construir distintas familias de sistemas
 relacionados
\end_layout

\begin_layout Standard
Ventajas:
\end_layout

\begin_layout Itemize
futuros cambios intercambiando algunos filtros;
\end_layout

\begin_layout Itemize
pequeñas transformaciones son más fácilmente reutilizadas;
\end_layout

\begin_layout Itemize
los datos pueden tener diferentes formatos.
\end_layout

\begin_layout Standard
En este caso, la entrada para los filtros es una lista de tokens, por lo
 que el filtro ejecutará acciones sobre los tokens de la lista (modificar
 la palabra, agregar atributos), para luego devolver la lista de tokens
 modificada.
\end_layout

\begin_layout Subsubsection
Filtro Lower Case
\end_layout

\begin_layout Standard
Filtro encargado de pasar las palabras a minúsculas.
 Para el ejemplo anterior, solo se modificarían los tokens que su palabra
 tenga alguna mayúscula.
\end_layout

\begin_layout Subsubsection
Filtro Stop Words
\end_layout

\begin_layout Standard
Se eliminan las denominadas stop-words, que son palabras qué, desde el punto
 de vista no lingüístico, no contienen información relevante.
 Las stop-words difieren de acuerdo al lenguaje, en el caso del idioma Español
 podemos mencionar artículos, preposiciones, etc.
 (por ejemplo: a, de, del, el, en, ella, los, se).
 
\end_layout

\begin_layout Subsubsection
Filtro Stemming
\end_layout

\begin_layout Standard
Dado que diferentes variantes de una misma palabra pueden ser problemáticas
 al realizar análisis de texto porque tienen diferente deletreo pero el
 mismo significado, por ejemplo: aprender, aprenden, aprendió, aprender,
 se decidió utilizar stemming, que es el proceso de transformar una palabra
 en su raíz (stem).
 Para tal ejemplo, todas esas palabras estarían identificadas por su raíz,
 es decir “aprend”.
 Con el Stemming se aumenta el recall sobre el número de palabras que se
 pueden encontrar en una consulta a la ontología.
 Por ejemplo, una consulta sobre el término “bibliotecas” encontrará instancias
 en las que solo aparezca “bibliotecario” ya que el stem de las dos palabras
 es el mismo (”bibliotec”).
 Para realizar el stemming se utiliza uno de los algoritmos más comunes
 y ampliamente usados, el algoritmo de Porter.
\end_layout

\begin_layout Standard
Diagrama XX.
 Algoritmo de Porter.
\end_layout

\begin_layout Standard
Continuando con el ejemplo anterior, se llevarían las palabras de los tokens
 a su raíz:
\end_layout

\begin_layout Subsubsection
Filtro Ocurrencias
\end_layout

\begin_layout Standard
Este algoritmo elimina tokens duplicados en la lista y enriquece cada token
 con el número de ocurrencias.
 Para los tokens obtenidos de los casos de uso se considera un token duplicado
 en caso de que el token sea la misma palabra y además aparezca en la misma
 sección.
 
\end_layout

\begin_layout Subsubsection
Filtro Pesos
\end_layout

\begin_layout Standard
Este filtro es aplicado para enriquecer los tokens de la lista de tokens
 de casos de uso asignando un peso a cada token.
 Este peso depende de la sección donde aparece la palabra.
 Por ejemplo se asignará un peso alto a una palabra que pertenece al nombre
 o descripción del caso de uso, mientras que se asignará un peso más bajo
 a una palabra perteneciente a un flujo alternativo.
 
\end_layout

\begin_layout Standard
Siguiendo el ejemplo, y suponiendo que para la sección “nombre” se asigna
 un peso de 5 y para la sección “descripción” un peso de 4, la lista de
 tokens final quedaría de la siguiente forma:
\end_layout

\begin_layout Standard
Los filtros ejecutados sobre la lista de tokens de Casos de Uso son:
\end_layout

\begin_layout Itemize
Lower Case
\end_layout

\begin_layout Itemize
Stop Words
\end_layout

\begin_layout Itemize
Stemming
\end_layout

\begin_layout Itemize
Ocurrencias
\end_layout

\begin_layout Itemize
Pesos
\end_layout

\begin_layout Standard
Diagrama XX.
 Filtros utilizados para los Casos de Usos
\end_layout

\begin_layout Standard
Para el caso de los Early Aspect no es necesario aplicar el filtro de peso
 debido a que se considera que todas las palabras dentro del early aspect
 tienen el mismo peso para el algoritmo.
 Esta diferencia radica en que el caso de uso está dividido en secciones
 y claramente hay secciones que deben ser ponderadas sobre otras.
 De igual forma a la hora de formatear la ontología no se correrán todos
 los filtros sobre las palabras de la misma.
 Solo será necesario correr los tres primeros filtros para dejar las palabras
 pertenecientes a la ontología en el mismo formato que las listas de tokens.
\end_layout

\begin_layout Section
Etapa 2 (Cambiar despues por nombre de la etapa)
\end_layout

\begin_layout Standard
En la etapa 2 se encuentran todas las tareas necesarias para 
\begin_inset Quotes eld
\end_inset

descubrir
\begin_inset Quotes erd
\end_inset

 los atributos de calidad a partir de una lista de tokens extraidos de los
 casos de uso y del aspecto temprano.
 En este punto ya la entrada ha sido analizada, armando listas de tokens
 con la palabra de cada token pasada a minuscula, llevada a su raiz, ponderizand
ola de acuerdo a su peso y dejando constancia del numero de ocurrencias.
 De esta manera, a esta etapa llegan dos listas de tokens: una correspondiente
 a los casos de uso y otra correspondiente al aspecto temprano.
\end_layout

\begin_layout Standard
Por cada palabra de cada una de la lista de palabras se averigua el grado
 de pertenencia de esa palabra con los distintos atributos de calidad.
 Es decir, que tan ligada se encuentra esa palabra con los distintos atributos
 de calidad y en que porcentaje o grado.
 Para ello se hace uso de una ontologia.
\end_layout

\begin_layout Standard
El mecanismo anterior se repite para cada palabra y los resultados individuales
 de cada una se combinan en una ecuación definida, que tiene en cuenta el
 peso de cada uno de los tokens y el numero de ocurrencias de la misma,
 y que da como resultado un conjunto de atributos de calidad y un porcentaje
 asociado a cada uno de ellos.
 
\end_layout

\begin_layout Standard
Los cálculos anteriores se aplican a cada una de las listas, las de los
 casos de uso y la del aspecto temprano.
 Finalmente estos resultados parciales se combinan, obteniendo los resultados
 finales.
 
\end_layout

\begin_layout Subsection
Ontolgia
\end_layout

\begin_layout Standard
La funcion 
\shape italic
Grado de Pertenencia
\shape default
, o GP, es una funcion que se aplica a una palabra y cuyo resultado es un
 conjunto de atributos de calidad asociados a porecntajes, que indican el
 grado o porcentaje de pertenencia de esa palabra con los distintos atributos
 de calidad.
 Para realizar este cálculo, la funcion se basa en el análisis de una ontologia
 previamente definida y que se supone cargada por un experto.
 En las siguiente subsecciones se detallará y describirá la ontolgía usada,
 para finalmente explicitar el funcionamiento de la función GP.
\end_layout

\begin_layout Subsubsection
Definción de Ontología
\end_layout

\begin_layout Standard
La literatura de Inteligencia Artificial contiene varias definiciones de
 ontologías, muchas veces contrdictorias entre ellas.
 En este trabajo se acuerda en definir una ontologia de la siguiente manera:
 
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Una ontologia es un modelo de datos que describe conceptos en un dominio
 del discurso (tambien llamados clases), propiedades de cada concepto que
 describen las diversas características y atributos del concepto (slots,
 tambien llamados propiedades o roles) y restricciones sobre los slots.”
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"

\end_inset


\end_layout

\begin_layout Standard
Un dominio es un área de temática específica o un área de conocimiento,
 tal como medicina, fabricación de herramientas, bienes inmuebles, reparación
 automovilística, gestión financiera, etc.
\begin_inset CommandInset citation
LatexCommand cite
key "key-2"

\end_inset

 Las ontologías incluyen definiciones de conceptos básicos del dominio,
 y las relaciones entre ellos, que son útiles para los sistemas, codifican
 el conocimiento de un dominio específico y también el conocimiento que
 extiende de los dominios.
 Un dominio específico es la parte del mundo que se quiere modelar.
 Representa el significado aplicado a los términos usados en la construcción
 de la ontología.
 Una ontología es la descripción de los conceptos que forman parte del dominio
 según un punto de vista.
 Un sistema sólo conoce lo que puede representar en algún lenguaje, por
 lo tanto, todo lo que no se exprese en la ontología no será conocido para
 el sistema que use la ontología.
 Un beneficio principal cuando una ontología es creada es:”Compartir el
 entendimiento común de la estructura de información entre personas y sistemas
 de software” 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

.
 Las ontologías se usan para favorecer la comunicación y la comprensión
 común de la información entre personas, organizaciones y aplicaciones,
 permitiendo que entre ellas estén de acuerdo en los términos que usan cuando
 se comunican.
\end_layout

\begin_layout Standard
Los beneficios de utilizar ontologías se pueden resumir de la siguiente
 manera:
\end_layout

\begin_layout Itemize
Compartir un entendimiento común de la estrucura de la información entre
 personas o agentes de software.
\end_layout

\begin_layout Itemize
Permitir el rehuso de un conocimiento del dominio.
 
\end_layout

\begin_layout Itemize
Hacer explicitas presunciones de un dominio.
\end_layout

\begin_layout Itemize
Separar el conocmiento del dominio del comocimiento operacional.
\end_layout

\begin_layout Itemize
Analizar el conocimiento del dominio.
\end_layout

\begin_layout Subsubsection
Componentes de una ontologia
\end_layout

\begin_layout Standard
Las ontologías tienen los siguientes componentes que servirán para representar
 el conocimiento de algún dominio 
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"

\end_inset

.
 Los principales son
\end_layout

\begin_layout Description
Conceptos
\begin_inset space ~
\end_inset

o
\begin_inset space ~
\end_inset

Clases Generalmente el foco de cualquier ontologia, las clases son las ideas
 básicas que se intentan formalizar.
 Por ejemplo, en una ontologia de vinos, la clase “Vino” representa todos
 los vinos.
 Una clase tambien puede tener sub-clases que representan conceptos que
 son mas especificos que las superclases.
 Por ejemplo, sublclases de la vlase “Vino” podrian ser “Tinto”, “Blanco”,
 “Rosado”, etc.
 
\end_layout

\begin_layout Description
Instancias Las instancias son representaciones de objetos determinados de
 un concepto.
 Siguiendo el ejemplo anterior, un vinos especificos son instancias de la
 clase “Vino”.
 Una botella de NewAge que se vende en el supermercado es una instancia
 de la clase “Vino”.
 
\end_layout

\begin_layout Description
Propiedades
\begin_inset space ~
\end_inset

o
\begin_inset space ~
\end_inset

Slots Los slots describen propiedades de clases o instancias.
 En el ejemplo anterior “New Age” es la marca del vino.
 Por lo tanto, esa instancia posee un slot(propiedad), que poseen todas
 las instancias de la clase “Vino”, que podria denominarse marca, y cuyo
 valor es la cadena de caracteres “New Age”.
 El valor de una propiedad puede ser una cadena de caracteres, un numero,
 otra instancia, etc.
 En el caso de que fuera otra instancia se forma lo que se denomina una
 relación.
\end_layout

\begin_layout Subsubsection
Lenguajes de implementación de ontologías: OWL
\end_layout

\begin_layout Standard
OWL (Ontology Web Languague) es un lenguaje web para ontologías compatible
 con la World Wide Web .
 OWL es utilizado cuando la información contenida en los documentos necesitan
 ser procesados por las aplicaciones, a diferencia de situaciones en que
 el contenido sólo es necesario presentar a los seres humanos.
 OWL puede ser utilizado para representar explícitamente el significado
 de los términos en los vocabularios y las relaciones entre esos términos
 (justamente una ontología).
 OWL tiene más facilidades para expresar el sentido y la semántica que otros
 lenguajes como XML, RDF y RDF-S, y por lo tanto OWL va más allá de estos
 lenguajes en su capacidad para representar a la máquina de contenido interpreta
ble en la Web.
 Este lenguaje es una revisión del lenguaje de ontologías web DAML+OIL que
 incorpora lecciones aprendidas desde el diseño y aplicaciones de DAML+OIL.
 La especificación de este lenguaje se encuentra dentro de las recomendaciones
 de la W3C 
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"

\end_inset

.
 OWL se diferencia de otros leguajes porque OWL es un lenguaje de ontologías
 Web.
 Lenguajes anteriores han sido utilizados para desarrollar herramientas
 y ontologías destinadas a comunidades específicas (especialmente para ciencias
 y aplicaciones específicas de comercio electrónico), no fueron definidos
 para ser compatibles con la arquitectura de la World Wide Web en general,
 y la Web Semántica en particular.
 
\end_layout

\begin_layout Subsubsection
Ontologia propuesta
\end_layout

\begin_layout Standard
Como se dijo anteriormente, la funcion 
\shape italic
Grado de Pertenencia
\shape default
 utiliza una ontologia para su realizar su análsis.
 A continuación se muestra un diagrama con la ontologia propuesta.
 Su construcción se basa principalmente en conceptos, definiciones, y relaciones
 extraidas del libro 
\begin_inset Quotes eld
\end_inset

Software Architecture in Practice
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "key-5"

\end_inset

.Luego de la misma se brinda una explicación y justificación de los conceptos
 y de las relaciones que se presentan en la ontología.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ontologiaReducida.jpeg
	scale 30

\end_inset


\end_layout

\begin_layout Standard
El concepto de escenario de calidad fue presentado por Bass, Clements y
 Kazman, en el libro “Software Architecture in Practice”.
 Textualmente, la definición es:
\end_layout

\begin_layout Quotation
“A quality attribue scenario is a quality-attribute-specific requirement.”
\begin_inset CommandInset citation
LatexCommand cite
key "key-5"

\end_inset


\end_layout

\begin_layout Standard
Traduciendo, un escenario de calidad es un requerimiento específico de un
 atributo de calidad.
 De esta manera, los escenarios son utilizados para caracterizar atributos
 de calidad de una forma especifica.
\end_layout

\begin_layout Standard
Es por ello que en la ontologia se encuentran los conceptos 
\shape italic
QualityAttributeScenario
\shape default
 y 
\shape italic
QualityAttribute
\shape default
 relacionados por la propiedad 
\series bold
\shape slanted
isSpecificOf
\series default
\shape default
.
\end_layout

\begin_layout Standard
Un escenario de calidad esta formado por seis partes:
\end_layout

\begin_layout Description
Fuente
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

estímulo.
 Alguna entidad (un humano, un sistema de computación u otro actor) que
 genera una estimulo.
\end_layout

\begin_layout Description
Estímulo.
 Una condicion que necesita ser considerada cuando arriba al sistema.
\end_layout

\begin_layout Description
Ambiente.
 El estímulo ocurre bajo ciertas condiciones.
 El sistema puede estar sobrecargado o puede estar ejecutandose normalmente
 cuando el estimulo ocurre, o alguna otra condicion puede ser verdadera.
\end_layout

\begin_layout Description
Artefacto.
 Algun artefacto es estimulado.
 Este puede ser el sistema completo o alguna parte de él.
\end_layout

\begin_layout Description
Respuesta.
 La respuesta es una actividad llevada a cabo luego del arribo del estimulo.
\end_layout

\begin_layout Description
Medida
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

respuesta.
 Cuando la respuesta ocurre, debería ser medido de alguna manera así el
 requerimiento puede ser medido.
 
\end_layout

\begin_layout Standard
Los conceptos 
\shape italic
ConcreteSource
\shape default
, 
\shape italic
ConcreteStimulus
\shape default
, 
\shape italic
ConcreteEnviroment
\shape default
, 
\shape italic
ConcreteArtifact
\shape default
, 
\shape italic
ConcreteResponse
\shape default
 y 
\shape italic
ConcreteResponseMeasure
\shape default
 representan estas seis partes mencionadas.
 Todos estos conceptos derivan del concepto abstracto 
\shape italic
scenarioPart
\shape default
 que representa una parte de un escenario y a su vez cada uno se relaciona
 con el concepto 
\shape italic
Concrete Quality-Atrribute Scenario
\shape default
.
\end_layout

\begin_layout Standard
Se distinguen como escenarios generales de calidad a aquellos que son independie
ntes del sistema y pueden, potencialmente, pertenecer a cualquier sistema,
 de aquellos denominados escenarios concretos de calidad, que son específicos
 de un sistema en particular que esta bajo consideración.
\end_layout

\begin_layout Standard
Es por esto ultimo que aparece el concepto abstracto 
\shape italic
Quality-Atrribute Scenario, 
\shape default
mientras que los conceptos 
\shape italic
Quality-Attribute Scenario
\shape default
 y 
\shape italic
Quality-Attribute Scenario
\shape default
 derivan del mismo.
 A su vez la relacion 
\series bold
isDerivedFrom
\series default
 deja constancia del hecho de que un escenario concreta deriva de uno general,
 haciendo las partes del ultimos especificas de un sistema bajo consideracion.

\series bold
 
\end_layout

\begin_layout Standard
Una colección de escenarios concretos pueden ser usados como los requerimientos
 de calidad para un sistema.
 Cada escenario es suficientemente concreto para ser significativo para
 un arquitecto, y los detalles de la respuesta son suficientemente significaivos
 para soportar tests convalidando que los requerimientos hayan sido cumplimentad
os.
\end_layout

\begin_layout Section
Mapa
\end_layout

\begin_layout Standard
Se define un mapa como una conjunto de tuplas <K,V> , donde a K se lo denomina
 “clave” y a V se lo denomina “valor”.
 Un mapa no puede tener dos tuplas con claves idénticas, Es decir, dado
 un mapa M no existe ningún par de tuplas <K1, V> , <K2,V2> tal que K1=K2.
\end_layout

\begin_layout Subsection
Suma de dos mapas
\end_layout

\begin_layout Standard
Sean M1 y M2 dos mapas con igual numero de tuplas.
 Además toda clave K que pertenece a alguna tupla de M1, también pertenece
 a alguna tupla de M2.
 Sea además cualquier valor de V perteneciente a M1 y M2 un número real.
 Se define la suma M1+M2, como un mapa M3 en donde cada tupla que posee
 éste es el resultado de la suma de los valores de las tuplas de igual clave
 de M1 y M2.
 Por ejemplo, si tenemos el mapa 
\begin_inset Formula $M_{1}=(<K_{1},a>;<K_{2},b>)$
\end_inset

 y el mapa 
\begin_inset Formula $M_{2}=(<K_{1},c>;<K_{2},d>)$
\end_inset

 se define 
\begin_inset Formula $M_{1}+M_{2}=(<K_{1},a+c>;<K_{2},b+d>)$
\end_inset

 siendo K1 y K2 claves; a, b, c y d números reales
\end_layout

\begin_layout Subsection
Division de dos mapas
\end_layout

\begin_layout Standard
Sea M un mapa compuesto por un conjunto de tuplas <K,V> donde K es la clave
 y V son números reales.
 Sea x un numero real distinto de cero.
 La división de M por x da como resultado el mismo mapa, con todos los valores
 V divididos por ese numero.
 Por ejemplo, si 
\begin_inset Formula $M=(<K_{1},a>;<K_{2},b>)$
\end_inset

, entonces 
\begin_inset Formula $M/x=(<K_{1},a/x>;<K_{2},b/x>)$
\end_inset

, siendo a,b y x numero reales; M un mapa; K1,K2 claves del mapa.
 
\end_layout

\begin_layout Subsection
Multipliacion de un mapa por un numero real
\end_layout

\begin_layout Standard
Sea M un mapa compuesto por un conjunto de tuplas <K,V> donde K es la clave
 y V son números reales.
 Sea x un numero real.
 La multiplicación de M por x da como resultado el mismo mapa, con todos
 los valores V multiplicados por ese numero.
 Por ejemplo, si
\begin_inset Formula $M=(<K_{1},a>;<K_{2},b>)$
\end_inset

, entonces 
\begin_inset Formula $M\times x=(<K_{1},a\times x>;<K_{2},b\times x>)$
\end_inset

, siendo a,b y x numeros reales; M un mapa; K1,K2 claves del mapa.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Ontology Development 101: A Guide to Creating Your First Ontology Escenario
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

OWL Web Ontology Language - Use Cases and Requirements (W3C Recommendation-
 http://www.w3.org/TR/webont-req/), 2004.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Gruber, T.
 R.
 A translation approach to portable ontology specifications (Knowl.
 Acquis., Vol.
 5, No.
 2.
 (June 1993), pp.
 199-220.).
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

OWL Web Ontology Language Overview (W3C Recommendation - 10 February 2004)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

Software Architecture in Practice, Second Edition.
\end_layout

\end_body
\end_document
